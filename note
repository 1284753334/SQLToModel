

迁移
    分步实现
            生成迁移文件
            执行迁移文件
        迁移文件的生成
            根据models 文件生成对应的迁移文件
            根据models 文件和 已有的迁移文件的差别 生成新的 迁移文件
        执行迁移文件
            先去迁移记录查找，哪些文件未迁移过
                app+label  + 迁移文件名字
            执行未迁移的文件
            执行完毕，记录执行过的迁移文件

        重新迁移
            删除迁移文件
            删除迁移文件产生的表
            删除迁移记录

    模型关系
        1:1
            应用场景
                用于复杂场景的拆分
                拓展新功能
            Django 中 OneToOneField
                 使用的时候，关系声明还是有细微差别的
             实现
                 使用外键实现的
                    对外键添加了唯一约束

                   人与 id 绑定    id做一对一关联，删除人  id也会删除
                数据删除
                主表
                从表 声明关系的是 从表
                主表删除，从表消失
                当系统遭遇不可避免的毁灭时，只能保留一张表，这个表就是主表
            默认特性（CASECARD）
                    从表数据删除，主表不受影响
                    主表数据删除，从表直接消失
            PROTECT受保护
                开发中位来防止误操作，我们通常设置此模式
                如果主表存在受保护的级联数据， 无法直接删除
                要想删除，需要先删除从表，再删除主表

            SET
                    SET_NULL
                    SET_DEFAULT
                    SET()
                        设置自定义值
            级联数据的获取：
                主获取从，
                    隐形属性，默认就是级联模型的名字
                从获取主，
                显性属性，通过外键属性




        1:M
        ForeignKey
            主从获取
                主获取从  隐形属性 级联模型——set
                student_set Manaager的子类
                    all
                    filter
                    exclude
                    Manager上能使用的函数都能使用
            从获取主
                显性属性


        M：N
            实际上最复杂
            开发中很少直接使用多对多属性，而是自己维护多对多关系
            产生表的时候，会产生单独的关系表
                关系表中存储关联表的主键，通过多个外键实现的
                多个外键值 不能同时相等

            级联数据的获取
                从获取主
                    使用属性 ，属性是一个Manager子类
                主获取从
                    隐形属性  -set.add
                    也是Manager 的子类


            级联数据

         ManyRelatedManager
          函数中定义的类
          并且父类是一个参数
          动态的创建

         实际的购物车 要另建一张表，两个外键（商品，顾客），在添加一些字段，
         商品数量，是否购买(  is_select)  etc


        模型的继承

        Django 中支持 模型继承
        默认继承会将 通用字段 放到 父表中， 特定字段 放到自己表中，中间
        使用 外键 连接
            关系型数据库 关系越复杂，效率越低，查询越慢

            父类表中，也会存储过多的数据
                使用模型抽象化
                抽象的模型就不会  再数据库中产生映射了
                子模型映射出来的表直接包含父模型的字段

         在企业开发中
             model---> sql
             sql-->model
                #可以直接根据数据库表直接生成模型
            python manage.py inspectdb >App/models.py

                # 生成的模型中 包含 manager = False 表明，迁移不归 该系统管理

            如果自己的模型不想被迁移系统管理，也可以使用 manager = False
                    进行声明


  静态资源  文件上传

    Django 高级


















